# -*- coding: utf-8 -*-
"""김주송 - HW03-k Means Clustering의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VVQsHVERloQwVzXfp8vqVLgIqPPGbG3v

# HW 03. Image Segmentation with k-Means Clustering

We are about to segment an image into sub-regions based on color similarity.
For that, we will apply k-means clustering in this homework.
The following code loads an image from the given URL.
The loaded image is in the form of a NumPy n-demensional array.
"""

from copy import deepcopy
from matplotlib.pyplot import imshow
import matplotlib.pyplot as plt
import cv2
import numpy as np
import imutils

# load an image from a url
img_url = 'https://snappygoat.com/b/5e3c07f2560b6420543d8e2367a70d3cdb08c39e'
img = imutils.url_to_image(img_url)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
imshow(img)
print(img.shape)

"""Before any pixel-based image processing (e.g., k-means), we first vectorize the image into an array of pixels for the sake of convenience. We represent an image as a 3-dimensional array with each dimension containing r, g, and b values, respectively."""

#reshape(행,열) => 배열의 차원을 재구조화
 #행의 위치에 -1이 들어갔다 => 열 차원의 정수가 빠짐없이 배치되도록
 #열의 위치에 3이 들어갔다 => 3차원
pixels = img.reshape((-1,3)) #pixels은 numpy.ndarray이다
pixels = np.float32(pixels)
print(pixels.shape)

"""We then process the 3d array for a given task.
Below is a simple blue-light filter that reduces the values of the blue channel.
Once you processed all pixels, you finally need to reshape the array into the format of a 2D image (i.e., height x width x channels).
"""

new_pixels = deepcopy(pixels)
# Blue light filter
new_pixels[:,2] = new_pixels[:,2] * 0.7
new_pixels = np.uint8(new_pixels)

# Reshape
result_img = new_pixels.reshape(img.shape) #다차원으로 변형
imshow(result_img)

"""## T1. Step-by-step implementaion

Here we go through the step-by-step implementation of k-means clustering.

### Step 1: Initializing k points
We first need to choose initial k positions in the 3d color space. Here we start with k=4. The function ***init()*** is provided to choose the initial positions based on the kmeans++ method.
"""

def init(ds, k, random_state=42):
    np.random.seed(random_state) #난수 생성
    centroids = [ds[0]]

    for _ in range(1, k):
        dist_sq = np.array([min([np.inner(c-x,c-x) for c in centroids]) for x in ds]) #두 배열의 내적의 가장 작은 값
        probs = dist_sq/dist_sq.sum()
        cumulative_probs = probs.cumsum() #배열에서 주어진 축에 따라 누적되는 원소들의 누적 합
        r = np.random.rand() #0부터 1 사이의 균일 분포에서 난수 생성

        #enumerate() 함수 -> 인덱스 번호와 컬렉션의 원소를 튜플 형태로 반환
        #j=인덱스 번호, p=컬렉션의 원소
        for j, p in enumerate(cumulative_probs):
          if r < p:
                i = j
                break

        centroids.append(ds[i])

    return np.array(centroids)

k = 4
centroids = init(pixels, k, random_state=42) #centroids 임의로 k개 설정
print(centroids)

"""### Step 2: Assigning all points to the closest centroid
Using the initial positions, we now assign all points in pixels to the closest centroid.
As we discussed in the class, "being closest" needs a definition. In other words, we need to measure the similarity between two pixels.
Consider r, g, b values of a pixel as a coordinate of a point in a 3d space.
Then we can think of the distance between pixels in the 3D space as a similarity (or distance) measure.
Here, we simply use Euclidean distance to calculate the similarity between pixels.


Please complete the following code and answer the following questions.
*italicized text*

#### Questions:

* Number of pixels in the first cluster? [*110736*]
"""

# First centroid
centroids[0]

# TODOs: Calculate distances between all points and the initial centroids.
distance = np.zeros((len(pixels), k))
for i in range(k):
  distance[:,i] = np.linalg.norm(pixels-centroids[i], axis=1)

# TODOs: Assign all points to their closest centroid.
clusters = np.argmin(distance, axis=1)

print(sum(clusters==0))

"""### Step 3: Recomputing the centroids

Now we need to recompute centroids for each cluster.
Please complete the code below and answer the questions.

#### Questions:
* Write coordinate of the new cetroid for the first cluster: [*19,132,202*]

Discard the decimal places when answering the question, but you should not round it up in the code.
"""

from numpy.lib import npyio
centroids_old = deepcopy(centroids)
centroids_new = np.zeros(centroids.shape)

# TODOs: Update centroids
for i in range(k):
  centroids_new[i] = np.mean(pixels[clusters==i], axis=0)

print(centroids_new[0])

"""#### Questions:
* Calculate the Sum of Squared Error (SSE): [*305200965.91*]

Round to 2 decimal places.

"""

# TODOs: Calculate SSE

SSE = 0
for i in range(len(pixels)):
  diff = pixels[i]-centroids_new[clusters[i]]
  SSE += np.sum(diff**2)

print(SSE)

"""### Step 4: Repeating step 2 and 3 until convergence

We are now ready to assemble the code snippets into a fully working k-means clustering algorithm.
As we discussed in the class, the algorithm repeats step 2 and step 3.
The final component left would be how we exit the iteration.

We can keep tracking SSE and exit the loop when SSE reaches its local minima, which can be simply determined by tracking the changes in centroids' positions in each iteration.

Complete the code below and answer the questions.

#### Questions:
* How many iterations were performed until the convergence condition met? [*11*]
"""

k = 4
centroids = init(pixels, k, random_state=42)

# Initial labels for each pixel
clusters = np.zeros(pixels.shape[0])

# TODOs
centroids_new = deepcopy(centroids)
centroids_old = np.zeros(centroids.shape)
distance = np.zeros((pixels.shape[0],k))
error = np.linalg.norm(centroids_new-centroids_old)
count=0
while error!=0:
  for i in range(k):
    distance[:,i] = np.linalg.norm(pixels-centroids_new[i],axis=1)
  centroids_old = deepcopy(centroids_new)
  clusters = np.argmin(distance,axis=1)
  for i in range(k):
    centroids_new[i] = np.mean(pixels[clusters==i],axis=0)
  error = np.linalg.norm(centroids_new-centroids_old)
  count += 1

print(count)

"""### Visualizing the segmentation result

You can execute the following code to show the segmented image.
Feel free to modify the code if needed.


"""

pixels_new = np.zeros(pixels.shape)

for i in range(k):
  pixels_new[clusters==i] = centroids_new[i]

pixels_new = np.uint8(pixels_new)
result_img = pixels_new.reshape(img.shape)
imshow(result_img)

"""## T2. k-means using Scikit-learn

Now we use [KMeans](https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html) for the same image segmentation task.
Complete the code below and show the segmented image with k = 3 using KMeans.
"""

from sklearn.cluster import KMeans
from matplotlib.pyplot import imshow
import cv2
import numpy as np
import imutils

# load an image from a url
img_url = 'https://snappygoat.com/b/5e3c07f2560b6420543d8e2367a70d3cdb08c39e'
img = imutils.url_to_image(img_url)
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
pixels = img.reshape((-1,3))
pixels = np.float32(pixels)


# TODOs
k = 3
model = KMeans(n_clusters=k,random_state=42)
model.fit(pixels)
label = model.labels_

pixels_new = np.zeros(pixels.shape)
cluster_centers = model.cluster_centers_
for i in range(k):
  pixels_new[label==i] = cluster_centers[i]
pixels_new = np.uint8(pixels_new)
result_img = pixels_new.reshape(img.shape)
imshow(result_img)